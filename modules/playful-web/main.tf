variable "domain" {
  type        = string
  description = "The user-facing root domain (this is 'playfulprogramming.com' in prod)"
}

variable "host" {
  type        = string
  description = "The backend hostname that requests are proxied to"
}

variable "noindex" {
  type        = bool
  description = "Whether a noindex header should be appended to every response"
}

resource "fastly_service_vcl" "cdn" {
  activate = true
  comment  = "Managed by Tofu"
  http3    = true
  name     = "PFP Website for ${var.domain}"
  stage    = false

  domain {
    name = var.domain
  }

  backend {
    address           = var.host
    name              = "Host 1"
    port              = 443
    prefer_ipv6       = true
    ssl_cert_hostname = var.host
    use_ssl           = true
  }

  gzip {
    content_types = [
      "text/html",
      "application/x-javascript",
      "text/css",
      "application/javascript",
      "text/javascript",
      "application/json",
      "application/vnd.ms-fontobject",
      "application/x-font-opentype",
      "application/x-font-truetype",
      "application/x-font-ttf",
      "application/xml",
      "font/eot",
      "font/opentype",
      "font/otf",
      "image/svg+xml",
      "image/vnd.microsoft.icon",
      "text/plain",
      "text/xml",
    ]
    extensions = [
      "css",
      "js",
      "html",
      "eot",
      "ico",
      "otf",
      "ttf",
      "json",
      "svg",
    ]
    name = "Generated by default compression policy"
  }

  header {
    action        = "set"
    destination   = "http.Strict-Transport-Security"
    ignore_if_set = false
    name          = "Generated by force TLS and enable HSTS"
    priority      = 100
    source        = "\"max-age=300\""
    type          = "response"
  }

  dynamic "header" {
    for_each = var.noindex ? [1] : []
    content {
      action        = "set"
      destination   = "http.X-Robots-Tag"
      ignore_if_set = false
      name          = "Prevent indexing in staging"
      priority      = 100
      source        = "\"noindex\""
      type          = "response"
    }
  }

  product_enablement {
    bot_management        = false
    brotli_compression    = false
    domain_inspector      = false
    image_optimizer       = false
    log_explorer_insights = false
    origin_inspector      = true
    websockets            = false
  }

  request_setting {
    bypass_busy_wait = false
    force_miss       = false
    force_ssl        = true
    max_stale_age    = 0
    name             = "Generated by force TLS and enable HSTS"
    timer_support    = false
  }
}

resource "fastly_tls_subscription" "main" {
  depends_on            = [fastly_service_vcl.cdn]
  domains               = [var.domain, "*.${var.domain}"]
  certificate_authority = "certainly"
}

resource "porkbun_dns_record" "domain_validation" {
  depends_on = [fastly_tls_subscription.main]
  for_each = {
    # Since the cert defines an apex (example.com) and a wildcard (*.example.com) domain, it will only return one challenge per domain
    for domain in fastly_tls_subscription.main.domains :
    replace(domain, "*.", "") => element([
      for obj in fastly_tls_subscription.main.managed_dns_challenges :
      obj if obj.record_name == "_acme-challenge.${replace(domain, "*.", "")}"
    ], 0)...
  }

  domain = regex("[^.]*\\.[^.]*$", each.value[0].record_name)
  subdomain = substr(
    each.value[0].record_name,
    0,
    length(each.value[0].record_name) - length(regex("[^.]*\\.[^.]*$", each.value[0].record_name)) - 1
  )
  type    = each.value[0].record_type
  content = each.value[0].record_value
  ttl     = 600
  prio    = 10
}

resource "fastly_tls_subscription_validation" "main" {
  subscription_id = fastly_tls_subscription.main.id
  depends_on      = [porkbun_dns_record.domain_validation]
}

data "fastly_tls_configuration" "default_tls" {
  default    = true
  depends_on = [fastly_tls_subscription_validation.main]
}

resource "porkbun_dns_record" "apex" {
  for_each = toset([for record in data.fastly_tls_configuration.default_tls.dns_records : record.record_value if record.record_type == "A"])

  domain    = var.domain
  subdomain = ""
  type      = "A"
  content   = each.value
  ttl       = 600
}
